Jansson conformance with RFC 4627

1. Strings.

Generally, JSON strings are mapped to C-style null-terminated
character (byte) arrays using the UTF-8 encoding.

Strings may not contain null characters (U+0000); which generally
means that jansson can not handle direct binary data encoded in JSON
strings.   The JSON standard allows this, but jansson follows the
established C language convention of null-terminated strings, so the
null character must be excluded.  (Note this could be allowed if
jansson introduced a second type of string value (binary string?)
which was a length/pointer pair rather than a C-style string ... or
perhaps with C++ wrappers by using the std::string class)

All other Unicode codepoints U+0001 through U+10FFFF, excluding the
surrogate pairs U+D800 to U+DFFF, are allowed.

2. Numbers.

  * JSON integer numbers are mapped to C "int" values.
  * JSON real numbers are mapped to C "double" values.

  * Real vs. Integer.  JSON makes no distinction between real and
integer numbers; C does.  Thus a JSON number is considered to be a
real number if its lexical representation includes one of: "e", "E",
or "."; regardless if its actual numeric value is a true integer.
(e.g., all of "1E6", "3.0", "400E-2", and "3.14E3" are mathematical
integers, but will be treated as real values and thus mapped to the C
double type).  When converted to JSON (dumping), real values are
always represented with a fractional part; e.g., the C double value
3.0 will be represented in JSON as "3.0", not "3".

  * Numbers that are too large to fit in one type are not promoted to
another; thus very large integers may result in an overflow rather
than conversion to a double, regardless if such conversion could be
lossless or lossy.  Thus, depending on platform, the JSON number
1000000000000000 may result in an overflow (see below) rather than
being converted to the mathematically equivalent 1.0E+15.

  * No support is provided in jansson for any C numeric types other
than 'int' and 'double'.  This excludes things such as unsigned types,
long, long long, long double, etc.  Obviously, shorter types like
'short' and 'float' are implicitly handled via the ordinary C type
coercion rules (subject to overflow semantics).  Also, no support or
hooks are provided for any supplemental "bignum" type add-on packages.

  * Signed zeros.  JSON makes no statement about what a number means;
however Javascript (ECMAscript) does state that +0.0 and -0.0 must be
treated as being distinct values, i.e., -0.0 != 0.0.  The jansson
implementation relies on the underlying floating point library in the
C environment in which it is compiled.  Therefore it is platform-
dependent whether 0.0 and -0.0 will be distinct values.  Most
platforms that use the IEEE 754 floating-point standard will support
signed zeros.  Note this only applies to floating-point; neither JSON,
C, or IEEE support the concept of signed integers.

  * Underflow.  JSON real numbers that are too small to be represented
in a C double will result in an underflow error (a JSON decoding
error).  The number is not rounded to zero, approximated with DBL_MIN,
nor is an IEEE precision underflow indicator set.  Thus, depending on
platform, JSON numbers such as 1E-999 will result in a parsing error,
not 0.0.

  * Overflow (real).  JSON real numbers whose absolute values are too
large to be represented in a C 'double' type will result in an
overflow error (a JSON decoding error).  The number is not
approximated with DBL_MAX,  the an IEEE inf (or -inf) special values,
nor is it coerced to a potentially larger floating-point type like
'long double'.  Thus, depending on platform, JSON numbers like 1E+999
will result in a parsing error.

  * Overflow (integer).  JSON integer numbers whose absolute values
are too large to be represented in a C 'int' type will result in an
overflow error (a JSON decoding error).  They are not approximated
with INT_MAX or INT_MIN, nor are they coerced to potentially larger
types (long long) or to floating-point numbers.

  * Precision.  Parsing JSON real numbers may result in a loss of
precision.  As long as underflow or overflow does not occur (i.e. a
total loss of precision), then the rounded approximate value is
silently used.  Thus the JSON number 1.000000000000000005 may,
depending on platform, result in the C double 1.0.

3. Encoding.

Jansson only supports UTF-8 encoded JSON texts (or by implicatation
the US-ASCII subset).  It does not support or auto-detect any of the
other encodings mentioned in the RFC, namely UTF-16LE, UTF-16BE,
UTF-32LE or UTF-32BE.  (The RFC doesn't mandate that an implementation
must support those other encodings, but does suggest they could be
used and that parsers support autodetection)
